<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>
        Standalone WebGPU Reduce Primitive Test, with Configuration Pane
    </title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
</head>

<body>
    <p>
        This example is a self-contained use of the <code>reduce</code>
        primitive, meant to plot performance. This builds on
        the simpler
        <a href="reduce_example.html">functionality example</a>. Set your
        parameters in the pane and click "Start" to run and plot performance data
        for a WebGPU reduce. The <code>inputCount</code> input specifies
        how many different input lengths to run, which will be evenly
        (logarithmically) interpolated between the specified start and end
        lengths. Otherwise, the parameters are the same as in the
        <a href="reduce_example.html">functionality example</a>. This
        example explains
        <a href="/gridwise/docs/gridwise/timing-strategy.html">how to time a Gridwise primitive</a>.
        <a href="https://github.com/gridwise-webgpu/gridwise/blob/main/examples/reduceperf.mjs">The entire JS source
            file is in github.</a>
    </p>
    <p>
        To measure CPU and/or GPU timing, include a timing directive in the call
        to <code>primitive.execute</code>. Typically we call the primitive once
        without any timing information to handle warmup effects (e.g., compiling
        the kernel) and then call the kernel many times and average the runtimes
        of that second set of calls. We then average the total runtime over the
        number of trials.
    </p>
    <pre><code class="language-javascript">/* call the primitive once to warm up */
await primitive.execute({
  inputBuffer: memsrcBuffer,
  outputBuffer: memdestBuffer,
});
/* call params.trials times */
await primitive.execute({
  inputBuffer: memsrcBuffer,
  outputBuffer: memdestBuffer,
  trials: params.trials, /* integer */
  enableGPUTiming: true,
  enableCPUTiming: true,
});</code></pre>
    <p>
        We can get timing information back from the primitive with a `getResults`
        call. The GPU time might be an array of timings if the GPU call has
        multiple kernels within it. In the below example, we simply flatten that
        array by adding it up into a total time.
    </p>
    <pre><code class="language-javascript">let { gpuTotalTimeNS, cpuTotalTimeNS } = await primitive.getTimingResult();
if (gpuTotalTimeNS instanceof Array) {
  // gpuTotalTimeNS might be a list, in which case just sum it up
  gpuTotalTimeNS = gpuTotalTimeNS.reduce((x, a) => x + a, 0);
}
averageGpuTotalTimeNS = gpuTotalTimeNS / params.trials;
averageCpuTotalTimeNS = cpuTotalTimeNS / params.trials;</code></pre>
    <p>
        The <code>reduce</code> primitive computes a single output value from an
        input array using a binary operation (such as add, max, or min). This makes
        it simpler to time than sort (which overwrites its input) since the input
        remains unchanged after each execution.
    </p>
    <hr />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
    <script src="reduce_perf.mjs" type="module"></script>
    <div id="webgpu-results"></div>
    <div id="plot"></div>
</body>

</html>