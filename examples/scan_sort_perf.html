<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Standalone WebGPU Scan/Reduce/Sort Performance Test</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
  </head>

  <body>
    <p>
      This example is a self-contained use of the <code>scan</code> and
      <code>sort</code> primitives, meant to plot performance. This builds on
      the simpler
      <a href="scan_sort_pane_example.html">functionality example</a>. Set your
      parameters in the pane and click "Start" to run and plot performance data
      for a WebGPU scan/reduce/sort. The <code>inputCount</code> input specifies
      how many different input lengths to run, which will be evenly
      (logarithmically) interpolated between the specified start and end
      lengths. Otherwise, the parameters are the same as in the
      <a href="scan_sort_pane_example.html">functionality example</a>. This
      example explains
      <a href="/gridwise/docs/gridwise/timing-strategy.html"
        >how to time a Gridwise primitive</a
      >.
      <a
        href="https://github.com/gridwise-webgpu/gridwise/blob/main/examples/scan_sort_perf.mjs"
        >The entire JS source file is in github.</a
      >
    </p>
    <p>
      To measure CPU and/or GPU timing, include a timing directive in the call
      to <code>primitive.execute</code>. Typically we call the primitive once
      without any timing information to handle warmup effects (e.g., compiling
      the kernel) and then call the kernel many times and average the runtimes
      of that second set of calls. We then average the total runtime over the
      number of trials.
    </p>
    <pre><code class="language-javascript">/* call the primitive once to warm up */
await primitive.execute({
  inputBuffer: memsrcBuffer,
  outputBuffer: memdestBuffer,
});
/* call params.trials times */
await primitive.execute({
  inputBuffer: memsrcBuffer,
  outputBuffer: memdestBuffer,
  trials: params.trials, /* integer */
  enableGPUTiming: true,
  enableCPUTiming: true,
});</code></pre>
    <p>
      We can get timing information back from the primitive with a `getResults`
      call. The GPU time might be an array of timings if the GPU call has
      multiple kernels within it. In the below example, we simply flatten that
      array by adding it up into a total time.
    </p>
    <pre><code class="language-javascript">let { gpuTotalTimeNS, cpuTotalTimeNS } = await primitive.getTimingResult();
if (gpuTotalTimeNS instanceof Array) {
  // gpuTotalTimeNS might be a list, in which case just sum it up
  gpuTotalTimeNS = gpuTotalTimeNS.reduce((x, a) => x + a, 0);
}
averageGpuTotalTimeNS = gpuTotalTimeNS / params.trials;
averageCpuTotalTimeNS = cpuTotalTimeNS / params.trials;</code></pre>
    <p>
      Timing the <code>sort</code> primitive is frustratingly complicated
      because sort overwrites its input with its output. The most meaningful
      timing results will therefore need to reset sort's input on each pass to
      make sure it has the same workload on each pass. For simplicity, we are
      not doing that here.
    </p>
    <hr />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="scan_sort_perf.mjs" type="module"></script>
    <div id="webgpu-results"></div>
    <div id="plot"></div>
  </body>
</html>
