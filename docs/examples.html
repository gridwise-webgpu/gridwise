---
layout: home
title: Examples
permalink: /examples-guide/
---

<style>
    .doc-btn {
        display: inline-block;
        padding: 8px 14px;
        background: #39bda7;
        color: white;
        text-decoration: none;
        border-radius: 4px;
        margin-right: 8px;
        margin-bottom: 10px;
        font-size: 14px;
        transition: background 0.2s;
    }

    .doc-btn:hover {
        background: #2a9a87;
        text-decoration: none;
        color: white;
    }

    .code-block {
        background: #ffffff;
        border: 2px solid #e1e4e8;
        border-radius: 6px;
        padding: 16px;
        overflow-x: auto;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        margin: 10px 0;
        color: #24292e;
        line-height: 1.6;
        box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        position: relative;
    }

    .copy-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: 6px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 12px;
        color: #24292f;
        transition: all 0.2s;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    }

    .copy-btn:hover {
        background: #f3f4f6;
        border-color: #b1b7be;
    }

    .copy-btn:active {
        background: #e8eaed;
    }

    .copy-btn.copied {
        color: #2da44e;
        border-color: #2da44e;
    }

    .perf-graph-container {
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
    }

    .perf-graph-container h4 {
        color: #333;
        margin-bottom: 15px;
        font-size: 16px;
    }

    .perf-canvas {
        width: 100%;
        height: 300px;
        border-radius: 4px;
        background: #fafafa;
        cursor: crosshair;
    }

    .perf-status {
        margin-top: 10px;
        font-size: 12px;
        color: #666;
        text-align: center;
    }

    .perf-status.running {
        color: #39bda7;
        font-weight: 500;
    }

    .graph-legend {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin-bottom: 10px;
        font-size: 13px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .legend-line {
        width: 30px;
        height: 2px;
        display: inline-block;
    }

    .gpu-line { background: #10b981; }
    .cpu-line { background: #000000; }

    .example-section {
        margin-bottom: 40px;
        background: #ffffff;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        padding: 30px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .example-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        align-items: start;
        margin-top: 20px;
    }

    .code-column {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 20px;
    }

    .code-column h3 {
        font-size: 18px;
        margin-bottom: 15px;
        margin-top: 0;
        color: #2c3e50;
    }

    .code-column h4 {
        font-size: 15px;
        margin-top: 15px;
        margin-bottom: 10px;
        color: #34495e;
    }

    .graph-column {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 20px;
    }

    .graph-column h3 {
        font-size: 18px;
        margin-bottom: 15px;
        margin-top: 0;
        color: #2c3e50;
    }

    @media (max-width: 968px) {
        .example-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
<p>Explore practical examples demonstrating how to use Gridwise WebGPU primitives for scan, sort, and reduce
    operations. Each example includes code snippets, explanations of key concepts, and links to source code and
    performance benchmarks.</p>

<div class="example-section">
<h2>Scan Example</h2>
<p>Compact example that demonstrates exclusive vs inclusive scans using DLDFScan: how to choose scanType, build the
    input array, run the primitive, and validate outputs. Good for understanding prefix-sum semantics and the effect of
    different binary ops (add/max/min).</p>

<div class="example-grid">
    <div class="code-column">
        <h3>Code</h3>
        <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this, 'scan')">ðŸ“‹ Copy</button>
    // Exclusive scan with add operation<br>
    const primitive = new DLDFScan({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;binop: new BinOpAdd({ datatype: "u32" }),<br>
    &nbsp;&nbsp;type: "exclusive",<br>
    &nbsp;&nbsp;datatype: "u32"<br>
    });<br>
    <br>
    // Inclusive scan with max operation<br>
    const primitive = new DLDFScan({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;binop: new BinOpMax({ datatype: "i32" }),<br>
    &nbsp;&nbsp;type: "inclusive",<br>
    &nbsp;&nbsp;datatype: "i32"<br>
    });
        </div>
    </div>

    <div class="graph-column">
        <h3>Performance Graph</h3>
        <div class="perf-graph-container">
            <div class="graph-legend">
                <div class="legend-item">
                    <span class="legend-line gpu-line"></span>
                    <span>GPU Bandwidth</span>
                </div>
                <div class="legend-item">
                    <span class="legend-line cpu-line"></span>
                    <span>CPU Time</span>
                </div>
            </div>
            <canvas id="scanCanvas" class="perf-canvas"></canvas>
            <div id="scanStatus" class="perf-status">Initializing...</div>
        </div>
    </div>
</div>
</div>

<div class="example-section">
<h2>Sort</h2>
<p>Demonstrates OneSweepSort with two modes: key-only sorting and key-value pair sorting with payload validation. Shows
    how to configure the primitive for different operations and data types.</p>

<div class="example-grid">
    <div class="code-column">
        <h3>Code</h3>
        <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this, 'sort')">ðŸ“‹ Copy</button>
    // Key-only sort<br>
    const primitive = new OneSweepSort({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;datatype: "u32",<br>
    &nbsp;&nbsp;direction: "ascending",<br>
    &nbsp;&nbsp;copyOutputToTemp: true,<br>
    &nbsp;&nbsp;inputLength: 1024<br>
    });<br>
    <br>
    // Key-value pair sort<br>
    const primitive = new OneSweepSort({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;datatype: "u32",<br>
    &nbsp;&nbsp;direction: "ascending",<br>
    &nbsp;&nbsp;copyOutputToTemp: true,<br>
    &nbsp;&nbsp;type: "keyvalue",<br>
    &nbsp;&nbsp;inputLength: 1024<br>
    });
        </div>
    </div>

    <div class="graph-column">
        <h3>Performance Graph</h3>
        <div class="perf-graph-container">
            <div class="graph-legend">
                <div class="legend-item">
                    <span class="legend-line gpu-line"></span>
                    <span>GPU Bandwidth</span>
                </div>
                <div class="legend-item">
                    <span class="legend-line cpu-line"></span>
                    <span>CPU Time</span>
                </div>
            </div>
            <canvas id="sortCanvas" class="perf-canvas"></canvas>
            <div id="sortStatus" class="perf-status">Initializing...</div>
        </div>
    </div>
</div>
</div>

<div class="example-section">
<h2>Reduce Operation</h2>
<p>A minimal, hands-on example showing how to run the reduce primitive end-to-end: device setup, buffer upload, a single
    execution, and result readback. Use this to learn the basic API calls and validation pattern. Parameters shown:
    datatype and binop (add/max/min). Ideal as the first example before any benchmarking.</p>

<div class="example-grid">
    <div class="code-column">
        <h3>Code</h3>
        <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this, 'reduce')">ðŸ“‹ Copy</button>
    // Reduce with add operation<br>
    const primitive = new DLDFScan({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;binop: new BinOpAdd({ datatype: "u32" }),<br>
    &nbsp;&nbsp;type: "reduce",<br>
    &nbsp;&nbsp;datatype: "u32"<br>
    });<br>
    <br>
    // Reduce with min operation<br>
    const primitive = new DLDFScan({<br>
    &nbsp;&nbsp;device,<br>
    &nbsp;&nbsp;binop: new BinOpMin({ datatype: "i32" }),<br>
    &nbsp;&nbsp;type: "reduce",<br>
    &nbsp;&nbsp;datatype: "i32"<br>
    });
        </div>
    </div>

    <div class="graph-column">
        <h3>Performance Graph</h3>
        <div class="perf-graph-container">
            <div class="graph-legend">
                <div class="legend-item">
                    <span class="legend-line gpu-line"></span>
                    <span>GPU Bandwidth</span>
                </div>
                <div class="legend-item">
                    <span class="legend-line cpu-line"></span>
                    <span>CPU Time</span>
                </div>
            </div>
            <canvas id="reduceCanvas" class="perf-canvas"></canvas>
            <div id="reduceStatus" class="perf-status">Initializing...</div>
        </div>
    </div>
</div>
</div>

<hr>

<script>
// Copy code function
const codeSnippets = {
    scan: `// Exclusive scan with add operation
const primitive = new DLDFScan({
  device,
  binop: new BinOpAdd({ datatype: "u32" }),
  type: "exclusive",
  datatype: "u32"
});

// Inclusive scan with max operation
const primitive = new DLDFScan({
  device,
  binop: new BinOpMax({ datatype: "i32" }),
  type: "inclusive",
  datatype: "i32"
});`,
    sort: `// Key-only sort
const primitive = new OneSweepSort({
  device,
  datatype: "u32",
  direction: "ascending",
  copyOutputToTemp: true,
  inputLength: 1024
});

// Key-value pair sort
const primitive = new OneSweepSort({
  device,
  datatype: "u32",
  direction: "ascending",
  copyOutputToTemp: true,
  type: "keyvalue",
  inputLength: 1024
});`,
    reduce: `// Reduce with add operation
const primitive = new DLDFScan({
  device,
  binop: new BinOpAdd({ datatype: "u32" }),
  type: "reduce",
  datatype: "u32"
});

// Reduce with min operation
const primitive = new DLDFScan({
  device,
  binop: new BinOpMin({ datatype: "i32" }),
  type: "reduce",
  datatype: "i32"
});`
};

function copyCode(button, type) {
    const code = codeSnippets[type];
    navigator.clipboard.writeText(code).then(() => {
        const originalText = button.innerHTML;
        button.innerHTML = 'âœ“ Copied!';
        button.classList.add('copied');
        
        setTimeout(() => {
            button.innerHTML = originalText;
            button.classList.remove('copied');
        }, 2000);
    });
}
</script>

<script type="module">
import { BinOpAdd, makeBinOp } from "../binop.mjs";
import { datatypeToTypedArray } from "../util.mjs";
import { DLDFScan } from "../scandldf.mjs";
import { OneSweepSort } from "../onesweep.mjs";

// Initialize WebGPU
const adapter = await navigator.gpu?.requestAdapter();
if (!adapter) {
    document.querySelectorAll('.perf-status').forEach(el => {
        el.textContent = 'No GPU detected';
        el.style.color = '#ff4444';
    });
    document.querySelectorAll('.perf-canvas').forEach(canvas => {
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ff4444';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No GPU detected', canvas.width / 2, canvas.height / 2 - 10);
        ctx.fillStyle = '#666';
        ctx.font = '13px Arial';
        ctx.fillText('WebGPU is not supported on this device', canvas.width / 2, canvas.height / 2 + 15);
    });
    throw new Error('WebGPU not supported');
}

const hasSubgroups = adapter.features.has("subgroups");
const device = await adapter?.requestDevice({
    requiredLimits: { maxComputeWorkgroupStorageSize: 32768 },
    requiredFeatures: [...(hasSubgroups ? ["subgroups"] : [])],
});

// Graph drawing utility
class PerfGraph {
    constructor(canvasId, title) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.title = title;
        this.gpuData = [];
        this.cpuData = [];
        this.maxPoints = 15;
        this.hoveredPoint = null;
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Mouse interaction
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
    }

    resize() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width * window.devicePixelRatio;
        this.canvas.height = rect.height * window.devicePixelRatio;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        this.width = rect.width;
        this.height = rect.height;
        this.draw();
    }

    addPoint(inputSize, gpuBandwidth, cpuTimeMS) {
        this.gpuData.push({ inputSize, value: gpuBandwidth });
        this.cpuData.push({ inputSize, value: cpuTimeMS });
        if (this.gpuData.length > this.maxPoints) {
            this.gpuData.shift();
            this.cpuData.shift();
        }
        this.draw();
    }

    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const padding = 60;
        const graphWidth = this.width - padding * 2;
        
        let closestDist = Infinity;
        let closestPoint = null;
        
        this.gpuData.forEach((d, i) => {
            const pointX = padding + (graphWidth / Math.max(this.gpuData.length - 1, 1)) * i;
            const dist = Math.abs(x - pointX);
            
            if (dist < closestDist && dist < 30) {
                closestDist = dist;
                closestPoint = { 
                    index: i,
                    inputSize: d.inputSize, 
                    gpuBandwidth: d.value,
                    cpuTime: this.cpuData[i]?.value || 0
                };
            }
        });
        
        if (closestPoint !== this.hoveredPoint) {
            this.hoveredPoint = closestPoint;
            this.draw();
        }
    }

    handleMouseLeave() {
        if (this.hoveredPoint) {
            this.hoveredPoint = null;
            this.draw();
        }
    }

    draw() {
        const ctx = this.ctx;
        const padding = 60;
        const graphWidth = this.width - padding * 2;
        const graphHeight = this.height - padding * 2;

        // Clear
        ctx.clearRect(0, 0, this.width, this.height);

        if (this.gpuData.length === 0) {
            ctx.fillStyle = '#999';
            ctx.font = '13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Running benchmark...', this.width / 2, this.height / 2);
            return;
        }

        // Fixed Y-axis range: 0 to 3 GB/s
        const minY = 0;
        const maxY = 3;

        // Draw grid lines
        ctx.strokeStyle = '#e8e8e8';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 6; i++) {
            const y = padding + (graphHeight / 6) * i;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(this.width - padding, y);
            ctx.stroke();
        }

        // Y-axis labels (0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 GB/s)
        ctx.fillStyle = '#666';
        ctx.font = '11px Arial';
        ctx.textAlign = 'right';
        for (let i = 0; i <= 6; i++) {
            const value = maxY - (i * 0.5);
            const y = padding + (graphHeight / 6) * i;
            ctx.fillText(value.toFixed(1), padding - 10, y + 4);
        }

        // X-axis labels (input size)
        ctx.textAlign = 'center';
        this.gpuData.forEach((d, i) => {
            if (i % 2 === 0 || i === this.gpuData.length - 1) {
                const x = padding + (graphWidth / Math.max(this.gpuData.length - 1, 1)) * i;
                const sizeLabel = d.inputSize >= 1048576 
                    ? (d.inputSize / 1048576).toFixed(1) + 'M'
                    : (d.inputSize / 1024).toFixed(0) + 'K';
                ctx.fillText(sizeLabel, x, this.height - padding + 20);
            }
        });

        // Draw GPU line (thin green)
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        this.gpuData.forEach((d, i) => {
            const x = padding + (graphWidth / Math.max(this.gpuData.length - 1, 1)) * i;
            const y = this.height - padding - ((d.value - minY) / (maxY - minY)) * graphHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();

        // Draw GPU points
        this.gpuData.forEach((d, i) => {
            const x = padding + (graphWidth / Math.max(this.gpuData.length - 1, 1)) * i;
            const y = this.height - padding - ((d.value - minY) / (maxY - minY)) * graphHeight;
            
            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw CPU line (thin black) - scaled to fit 0-3 range proportionally
        const maxCpu = Math.max(...this.cpuData.map(d => d.value), 1);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        this.cpuData.forEach((d, i) => {
            const x = padding + (graphWidth / Math.max(this.cpuData.length - 1, 1)) * i;
            // Scale CPU time to fit within 0-2.5 range for visibility
            const scaledValue = (d.value / maxCpu) * 2.5;
            const y = this.height - padding - ((scaledValue - minY) / (maxY - minY)) * graphHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();

        // Draw CPU points
        this.cpuData.forEach((d, i) => {
            const x = padding + (graphWidth / Math.max(this.cpuData.length - 1, 1)) * i;
            const scaledValue = (d.value / maxCpu) * 2.5;
            const y = this.height - padding - ((scaledValue - minY) / (maxY - minY)) * graphHeight;
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw axes
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, this.height - padding);
        ctx.lineTo(this.width - padding, this.height - padding);
        ctx.stroke();

        // Axis labels
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Input Size', this.width / 2, this.height - 5);
        
        ctx.save();
        ctx.translate(15, this.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Bandwidth (GB/s)', 0, 0);
        ctx.restore();

        // Draw tooltip if hovering
        if (this.hoveredPoint) {
            this.drawTooltip(this.hoveredPoint);
        }
    }

    drawTooltip(point) {
        const ctx = this.ctx;
        const padding = 60;
        const graphWidth = this.width - padding * 2;
        const x = padding + (graphWidth / Math.max(this.gpuData.length - 1, 1)) * point.index;
        
        const tooltipWidth = 160;
        const tooltipHeight = 70;
        let tooltipX = x + 15;
        let tooltipY = 20;
        
        if (tooltipX + tooltipWidth > this.width - 20) {
            tooltipX = x - tooltipWidth - 15;
        }
        
        // Draw tooltip background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip text
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        
        const sizeLabel = point.inputSize >= 1048576 
            ? `${(point.inputSize / 1048576).toFixed(1)}M` 
            : `${(point.inputSize / 1024).toFixed(0)}K`;
        
        ctx.fillText(`Size: ${sizeLabel}`, tooltipX + 10, tooltipY + 20);
        ctx.fillText(`GPU: ${point.gpuBandwidth.toFixed(2)} GB/s`, tooltipX + 10, tooltipY + 40);
        ctx.fillText(`CPU: ${point.cpuTime.toFixed(2)} ms`, tooltipX + 10, tooltipY + 60);
    }
}

// Benchmark runner
async function runBenchmark(primitive, inputSizes, graph, statusId, config) {
    const statusEl = document.getElementById(statusId);
    
    for (let i = 0; i < inputSizes.length; i++) {
        const inputLength = inputSizes[i];
        statusEl.textContent = `Running ${i + 1}/${inputSizes.length}: ${(inputLength / 1048576).toFixed(1)}M elements...`;
        statusEl.className = 'perf-status running';

        const memsrc = new (datatypeToTypedArray(config.datatype))(inputLength);
        memsrc.fill(1);

        let primitiveInstance;
        if (config.type === 'sort') {
            primitiveInstance = new OneSweepSort({
                device,
                datatype: config.datatype,
                direction: 'ascending',
                copyOutputToTemp: true,
            });
        } else {
            primitiveInstance = new DLDFScan({
                device,
                binop: makeBinOp({ op: config.binop, datatype: config.datatype }),
                type: config.type,
                datatype: config.datatype,
            });
        }

        const memdestBytes = config.type === 'reduce' ? 4 : memsrc.byteLength;
        const memsrcBuffer = device.createBuffer({
            size: memsrc.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
        const memdestBuffer = device.createBuffer({
            size: memdestBytes,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(memsrcBuffer, 0, memsrc);

        // Timing
        const cpuStart = performance.now();
        if (config.type === 'sort') {
            await primitiveInstance.execute({
                keysInOut: memsrcBuffer,
                keysTemp: memdestBuffer,
            });
        } else {
            await primitiveInstance.execute({
                inputBuffer: memsrcBuffer,
                outputBuffer: memdestBuffer,
            });
        }
        await device.queue.onSubmittedWorkDone();
        const cpuEnd = performance.now();

        const cpuTimeMS = cpuEnd - cpuStart;
        const totalBytes = memsrc.byteLength + memdestBytes;
        const bandwidth = (totalBytes / 1e9) / (cpuTimeMS / 1000);

        graph.addPoint(inputLength, bandwidth, cpuTimeMS);

        memsrcBuffer.destroy();
        memdestBuffer.destroy();

        await new Promise(r => setTimeout(r, 100));
    }

    statusEl.textContent = `âœ“ Benchmark complete`;
    statusEl.className = 'perf-status';
}

// Run benchmarks
const inputSizes = [
    2**16, 2**17, 2**18, 2**19, 2**20, 
    2**21, 2**22, 2**23, 2**24
];

const scanGraph = new PerfGraph('scanCanvas', 'Scan Performance');
const sortGraph = new PerfGraph('sortCanvas', 'Sort Performance');
const reduceGraph = new PerfGraph('reduceCanvas', 'Reduce Performance');

// Run all benchmarks in sequence
(async () => {
    await runBenchmark('scan', inputSizes, scanGraph, 'scanStatus', {
        type: 'exclusive',
        datatype: 'u32',
        binop: 'add',
    });

    await runBenchmark('sort', inputSizes, sortGraph, 'sortStatus', {
        type: 'sort',
        datatype: 'u32',
    });

    await runBenchmark('reduce', inputSizes, reduceGraph, 'reduceStatus', {
        type: 'reduce',
        datatype: 'u32',
        binop: 'add',
    });
})();
</script>